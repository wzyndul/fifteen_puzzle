Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom collections import deque\r\nimport sys\r\nimport time\r\n\r\nalgorithm_type = sys.argv[1]\r\npriority = sys.argv[2]\r\nwith open(f\"puzzles/{sys.argv[3]}\", \"r\") as f:\r\n    rows, cols = np.fromfile(f, dtype=int, count=2, sep=\" \")\r\n    data = np.fromfile(f, dtype=int, count=rows * cols, sep=\" \").reshape((rows, cols))\r\n\r\nlist_puzzle = data.flatten().tolist()\r\nROW = rows\r\nCOL = cols\r\nMAX_DEPTH = 20\r\n\r\n\r\ndef is_solved_v2(board):\r\n    solution = list(range(1, ROW * COL)) + [0]\r\n    return board == tuple(solution)\r\n\r\n\r\ndef change_state(board, move, index):\r\n    new_board = board.copy()\r\n    if move == \"U\":\r\n        temp = new_board[index - COL]\r\n        new_board[index - COL] = 0\r\n        new_board[index] = temp\r\n        return new_board\r\n\r\n    elif move == \"D\":\r\n        temp = new_board[index + COL]\r\n        new_board[index + COL] = 0\r\n        new_board[index] = temp\r\n        return new_board\r\n\r\n    elif move == \"R\":\r\n        temp = new_board[index + 1]\r\n        new_board[index + 1] = 0\r\n        new_board[index] = temp\r\n        return new_board\r\n\r\n    elif move == \"L\":\r\n        temp = new_board[index - 1]\r\n        new_board[index - 1] = 0\r\n        new_board[index] = temp\r\n        return new_board\r\n    return None\r\n\r\n\r\ndef dfs_algorithm_v2(board, path, visited, current_depth, priority, counter_visited_states):\r\n    if is_solved_v2(tuple(board)):\r\n        return path, counter_visited_states, len(visited)\r\n    if current_depth >= MAX_DEPTH:\r\n        return None\r\n    visited.add(hash(tuple(board)))\r\n    index = board.index(0)\r\n    for move in priority:\r\n        if move == \"U\" and index >= COL:  # mozna sie ruszyc do góry\r\n            if path == \"\" or path[-1] != \"D\":\r\n                new_board = change_state(board, \"U\", index)\r\n                counter_visited_states += 1\r\n                if hash(tuple(new_board)) not in visited:\r\n                    path += \"U\"  # path.append(\"U\")\r\n                    result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority, counter_visited_states)\r\n                    if result is not None:\r\n                        return result\r\n                    path = path[:-1]  # path.pop()\r\n        elif move == \"L\" and index % COL != 0:  # ruch w lewo\r\n            if path == \"\" or path[-1] != \"R\":\r\n                new_board = change_state(board, \"L\", index)\r\n                counter_visited_states += 1\r\n                if hash(tuple(new_board)) not in visited:\r\n                    path += \"L\"\r\n                    result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority, counter_visited_states)\r\n                    if result is not None:\r\n                        return result\r\n                    path = path[:-1]\r\n        elif move == \"D\" and index < COL * ROW - COL:  # ruch w dol\r\n            if path == \"\" or path[-1] != \"U\":\r\n                new_board = change_state(board, \"D\", index)\r\n                counter_visited_states += 1\r\n                if hash(tuple(new_board)) not in visited:\r\n                    path += \"D\"\r\n                    result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority, counter_visited_states)\r\n                    if result is not None:\r\n                        return result\r\n                    path = path[:-1]\r\n        elif move == \"R\" and (index + 1) % COL != 0 and index < COL * ROW - 1:  # ruch w prawo\r\n            if path == \"\" or path[-1] != \"L\":\r\n                new_board = change_state(board, \"R\", index)\r\n                counter_visited_states += 1\r\n                if hash(tuple(new_board)) not in visited:\r\n                    path += \"R\"\r\n                    result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority, counter_visited_states)\r\n                    if result is not None:\r\n                        return result\r\n                    path = path[:-1]\r\n    return None\r\n\r\n\r\n\r\ndef bfs_algorithm(board, priority):\r\n    visited = set()\r\n    q = deque([(board, \"\")])\r\n    visited.add(tuple(board))\r\n\r\n    while q:\r\n        state, path = q.popleft()\r\n        if is_solved_v2(tuple(state)):\r\n            return path\r\n\r\n        index = state.index(0)\r\n        for move in priority:\r\n            if move == \"U\" and index >= COL:  # mozna sie ruszyc do góry\r\n                new_board = change_state(state, \"U\", index)\r\n                if tuple(new_board) not in visited:\r\n                    visited.add(tuple(new_board))\r\n                    q.append((new_board, path + \"U\"))\r\n\r\n            elif move == \"L\" and index > 0 and index % COL != 0:  # ruch w lewo\r\n                new_board = change_state(state, \"L\", index)\r\n                if tuple(new_board) not in visited:\r\n                    visited.add(tuple(new_board))\r\n                    q.append((new_board, path + \"L\"))\r\n\r\n            elif move == \"D\" and index < COL * ROW - COL:  # ruch w dol\r\n                new_board = change_state(state, \"D\", index)\r\n                if tuple(new_board) not in visited:\r\n                    visited.add(tuple(new_board))\r\n                    q.append((new_board, path + \"D\"))\r\n\r\n            elif move == \"R\" and index + 1 % COL != 0 and index < COL * ROW - 1:  # ruch w prawo\r\n                new_board = change_state(state, \"R\", index)\r\n                if tuple(new_board) not in visited:\r\n                    visited.add(tuple(new_board))\r\n                    q.append((new_board, path + \"R\"))\r\n\r\n    return None\r\n\r\n\r\nalgorithm_result = None\r\nif sys.argv[1] == \"dfs\":\r\n\r\n    star_time = time.time_ns()\r\n    algorithm_result, visited_states, processed_states = dfs_algorithm_v2(list_puzzle, \"\", set(), 0, priority, 0)\r\n    elapsed_time = (time.time_ns() - star_time) / (10 ** 6)\r\n    print(round(elapsed_time, 3))\r\n    print(algorithm_result)\r\nelif sys.argv[1] == \"bfs\":\r\n    star_time = time.time_ns()\r\n    algorithm_result = bfs_algorithm(list_puzzle, priority)\r\n    elapsed_time = (time.time_ns() - star_time) / (10 ** 6)\r\n    print(round(elapsed_time, 3))\r\n    print(algorithm_result)\r\n\r\nwith open(f\"{sys.argv[4]}\", \"w\") as file:  # otwiera plik i automatycznie go zamyka jak skoncze pisac\r\n    if algorithm_result is not None:\r\n        file.write(f\"{len(algorithm_result)}\\n{algorithm_result}\")\r\n    else:\r\n        file.write(\"-1\")\r\n\r\n#TODO zrobic jakeis hashowanie do porównywania stanów w visited\r\n\r\n\r\n\r\n# STARA WERSJA PROGRAMU BEZ HASHOWANIA\r\n# def dfs_algorithm_v3(board, path, visited, current_depth, priority):\r\n#     if is_solved_v2(tuple(board)):\r\n#         return path\r\n#     if current_depth >= MAX_DEPTH:\r\n#         return None\r\n#     visited.add(tuple(board))\r\n#     index = board.index(0)\r\n#     for move in priority:\r\n#         if move == \"U\" and index >= COL:  # mozna sie ruszyc do góry\r\n#             if path == \"\" or path[-1] != \"D\":\r\n#                 new_board = change_state(board, \"U\", index)\r\n#                 if tuple(new_board) not in visited:\r\n#                     path += \"U\"  # path.append(\"U\")\r\n#                     result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority)\r\n#                     if result is not None:\r\n#                         return result\r\n#                     path = path[:-1]  # path.pop()\r\n#         elif move == \"L\" and index % COL != 0:  # ruch w lewo\r\n#             if path == \"\" or path[-1] != \"R\":\r\n#                 new_board = change_state(board, \"L\", index)\r\n#                 if tuple(new_board) not in visited:\r\n#                     path += \"L\"\r\n#                     result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority)\r\n#                     if result is not None:\r\n#                         return result\r\n#                     path = path[:-1]\r\n#         elif move == \"D\" and index < COL * ROW - COL:  # ruch w dol\r\n#             if path == \"\" or path[-1] != \"U\":\r\n#                 new_board = change_state(board, \"D\", index)\r\n#                 if tuple(new_board) not in visited:\r\n#                     path += \"D\"\r\n#                     result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority)\r\n#                     if result is not None:\r\n#                         return result\r\n#                     path = path[:-1]\r\n#         elif move == \"R\" and (index + 1) % COL != 0 and index < COL * ROW - 1:  # ruch w prawo\r\n#             if path == \"\" or path[-1] != \"L\":\r\n#                 new_board = change_state(board, \"R\", index)\r\n#                 if tuple(new_board) not in visited:\r\n#                     path += \"R\"\r\n#                     result = dfs_algorithm_v2(new_board, path, visited, current_depth + 1, priority)\r\n#                     if result is not None:\r\n#                         return result\r\n#                     path = path[:-1]\r\n#     return None
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision e2ba68c701f2ec519f12b33c0a6eacb9020f5e1c)
+++ b/main.py	(date 1678808678335)
@@ -147,6 +147,8 @@
     elapsed_time = (time.time_ns() - star_time) / (10 ** 6)
     print(round(elapsed_time, 3))
     print(algorithm_result)
+    print(visited_states)
+    print(processed_states)
 elif sys.argv[1] == "bfs":
     star_time = time.time_ns()
     algorithm_result = bfs_algorithm(list_puzzle, priority)
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.11\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision e2ba68c701f2ec519f12b33c0a6eacb9020f5e1c)
+++ b/.idea/misc.xml	(date 1678808507083)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/projekt.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.11\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n  <component name=\"PyDocumentationSettings\">\r\n    <option name=\"renderExternalDocumentation\" value=\"true\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/projekt.iml b/.idea/projekt.iml
--- a/.idea/projekt.iml	(revision e2ba68c701f2ec519f12b33c0a6eacb9020f5e1c)
+++ b/.idea/projekt.iml	(date 1678808507073)
@@ -2,7 +2,7 @@
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.11" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.9" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
